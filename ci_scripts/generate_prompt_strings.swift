import Foundation

struct Arguments {
    var stringsPath: String = "Sonora/Localizable.strings"
    var dryRun: Bool = false
    var headerComment: String = "/* === AUTO-GENERATED PROMPTS BEGIN === */"
    var footerComment: String = "/* === AUTO-GENERATED PROMPTS END === */"
}

func parseArguments() -> Arguments {
    var args = Arguments()
    var iterator = CommandLine.arguments.dropFirst().makeIterator()
    while let arg = iterator.next() {
        switch arg {
        case "--strings":
            if let path = iterator.next() { args.stringsPath = path }
        case "--dry-run":
            args.dryRun = true
        case "--help", "-h":
            print("Usage: swiftc <sources...> -o generate_prompt_strings && ./generate_prompt_strings [--strings path] [--dry-run]")
            exit(0)
        default:
            print("Unknown argument: \(arg)")
            exit(1)
        }
    }
    return args
}

@main
struct PromptStringsGenerator {
    static func main() throws {
        let arguments = parseArguments()
        let beginMarker = arguments.headerComment
        let endMarker = arguments.footerComment

        let definitions = PromptCatalogStatic.promptDefinitions()

        var lines: [String] = []
        lines.append("/* Generated by ci_scripts/generate_prompt_strings.swift. Do not edit manually. */")
        var lastCategory: PromptCategory?

        for definition in definitions {
            let category = definition.prompt.category
            if category != lastCategory {
                if lastCategory != nil { lines.append("") }
                let name = category.rawValue.capitalized
                lines.append("/* \(name) */")
                lastCategory = category
            }
            let key = definition.prompt.localizationKey
            let value = definition.defaultTemplate
                .replacingOccurrences(of: "\\", with: "\\\\")
                .replacingOccurrences(of: "\"", with: "\\\"")
            lines.append("\"\(key)\" = \"\(value)\";")
        }

        lines.append("")
        let generatedBlock = lines.joined(separator: "\n")

        let url = URL(fileURLWithPath: arguments.stringsPath)
        let data = try Data(contentsOf: url)
        let content = String(decoding: data, as: UTF8.self)

        guard let beginRange = content.range(of: beginMarker) else {
            print("error: begin marker not found in \(arguments.stringsPath)")
            exit(1)
        }

        guard let endRange = content.range(of: endMarker) else {
            print("error: end marker not found in \(arguments.stringsPath)")
            exit(1)
        }

        guard beginRange.lowerBound < endRange.lowerBound else {
            print("error: markers out of order in \(arguments.stringsPath)")
            exit(1)
        }

        let prefix = content[..<beginRange.upperBound]
        let suffix = content[endRange.lowerBound...]
        let replacement = "\n\(generatedBlock)\n"
        let updated = String(prefix) + replacement + String(suffix)

        if arguments.dryRun {
            print(updated)
        } else {
            try updated.write(to: url, atomically: true, encoding: .utf8)
        }
    }
}
